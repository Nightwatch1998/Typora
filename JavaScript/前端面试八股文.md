## JS数据类型

- 原始类型：number、string、boolean、null、undefined、symbol、bigInt
- 引用类型：Object、Array、函数

栈存放指针、堆存放实体

## 判断数据类型的办法

- typeof 判断基本数据类型
- instanceof 依据原型链判断
- constructor 对象的构造器
- Object.prototype.toString.call() 返回调用者的具体类型

## new操作符具体做了什么

```
1. 创建一个新的对象，在内存中创建一个新的地址
let obj = new Object()
2. 设置创建对象的原型链，继承构造函数的原型
obj._proto_ = 构造函数的.prototype
3. 将构造函数的this指向创建的对象
let result = Fn.call(创建的对象)
4. 判断构造函数的返回值类型
return result instanceof Object ? result:obj
```

## dom.onclick和dom.addEventListener区别？

dom.onclick:元素被点击是发生

- 可以在内联标签上添加事件，只能有一个，后来的会覆盖前者
- 潜在安全问题XSS跨站脚本攻击
- 内联不能分离文档结构和逻辑
- 只能处理冒泡阶段

dom.addEventListener:用于向元素添加事件，三个参数分别是事件、回调函数、是否在捕获和冒泡阶段执行

- 可以添加多个事件，按注册顺序执行
- 分离文档结构和逻辑
- 可以处理冒泡和捕获阶段，true表示在捕获阶段处理，false表示在冒泡阶段处理

## 作用域和作用域链

- 变量和函数可访问的范围，即作用域控制这个变量的可见性和生命周期
- 全局作用域，生命周期和页面生命周期等同
- 局部作用域，函数，{}内部声明的变量和函数

## 预解析和变量提升

预解析：JS引擎将JS所有var声明和function都提升到作用域的最前面

变量提升：将所有的变量声明提升到作用域的最前面

## 改变指向函数的三个方法

call和apply是使用后马上执行,bind是返回一个新的函数

call与apply的区别在于传参，call需要把参数列举出了

## ...args剩余参数和arguments对象的区别

- ...args只包含没有形参的实参，而arguments包含了传给函数的所有实参
- ...args是真正的Array实例，arguments不是真正的数组
- arguments还有附加属性callee

## 遍历方法

### 遍历数组

- for循环 
- forEach() 不能执行break和return
- map()
- for...of 可迭代的对象都可遍历

### 遍历对象

- for...in 遍历一个对象自由的、继承的、可枚举的、非Symbol的属性名
- Object.keys() 返回一个可枚举属性名组成的数组
- Object.values() 可枚举属性值
- Object.getOwnPropertyNames() 返回指定对象的所有自身属性名

### 遍历字符串

- for...of 
- for循环

## JS的NAN属性

NaN属性代表非数字值的特殊值，不可配置，不可写

NaN!==NaN

isNaN()判断是否为NaN

## null和undefined

```js
undefined == null //true
undefined === null //false
let a
typeof a //undefined
let b= null
typeof b //object
null表示空对象指针，JS的最初版本使用32位系统，为了性能考虑使用低位存储变量类型信息，000开头代表对象，而null表示为全零
```

## ===和==

==对比时，若类型不相同，会先转换为相同类型，然后再比较值

- 一个是null、一个是undefined、相等
- 一个是字符串、一个是数值、字符串转换为数值
- true/false转换为1/0
- 一个是对象、一个是数值和字符串
  - 先尝试valueOf()
  - toString()

===不会转换类型

## 0.1+0.2为什么不等于0.3

- 二进制存储
- 浮点数转换为整数计算

## 函数的length

- 形参的个数

```js
function fn1 () {}
function fn2 (name) {}
function fn3 (name, age) {}

console.log(fn1.length) // 0 
console.log(fn2.length) // 1 
console.log(fn3.length) // 2
```

- 第一个具有默认值之前的参数个数

```js
function fn1 (name) {} 
function fn2 (name = '林三心') {} 
function fn3 (name, age = 22) {} 
function fn4 (name, aaa, age = 22, gender) {} 
function fn5(name = '林三心', age, gender, aaa) {} 

console.log(fn1.length) // 1 
console.log(fn2.length) // 0 
console.log(fn3.length) // 1 
console.log(fn4.length) // 2
console.log(fn5.length) // 0
```

## DOM事件流

事件三要素：事件源、绑定事件、添加事件处理程序

事件流：

- 捕获阶段：DOM最顶层window开始，逐级向下寻找目标元素传播的过程，遇见绑定的捕获事件会向下传递
- 目标阶段：到达目标阶段出发绑定事件
- 冒泡阶段：事件开始由具体元素接受，逐级向上传播到DOM顶层window的过程

有了事件流，就可以控制事件在事件流的那一个环节执行

## 原型和原型链

## 中文的长度

js是unicode编码，所有的字符都是一个

前后端不一致的情况，可以用正则替换后再获取长度

## 简述cookie/session记录登录状态机制原理

第一次访问服务器，服务器会开辟一块空间来存放用户信息。

每一个登录之后的用户信息，都会以key-value格式记录在session中

同事服务器会把sessionId存在cookie中返回给客户端

客户端把sessionId保存在本地cookie中对应的网站记录下

下次访问携带这个sessionId

## 简述cookies、session、sessionStorage、localStorage区别

cookie

- 把数据存在用户的浏览器中
- 刷新页面不会丢失数据
- 只能存储字符串

session

- 位于web服务器，主要负责访问者与网站的交互，关闭网站时会话就已经结束

sessionStorage

- 生命周期为关闭浏览器
- 同一个窗口数据可共享

localStorage

- 生命周期为永久
- 多个窗口共享

cookie与sessionStorage、localStorage区别：

- cookie始终在同源的http请求中携带，另外两个不会自动发送到服务器
- cookie不能超过4k，另外两个可到5M以上
- 数据有效期不同：sessionStorage仅在浏览器窗口关闭之前有效，localStorage始终有效，窗口或浏览器关闭也一直保存；cookie在过期时间之前有效
- 作用域不同：sessionStorage在不同的浏览器窗口共享，localStorage和cookie在所有同源窗口共享

## for-in与for-of区别

- for-in：用于遍历对象可枚举属性，包括对象的原型链中的属性，遍历数组的索引
- for-of：用于遍历可迭代对象，不会遍历原型，遍历数组的值
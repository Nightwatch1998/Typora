## JS数据类型

- 原始类型：number、string、boolean、null、undefined、symbol、bigInt
- 引用类型：Object、Array、函数

栈存放指针、堆存放实体

## 判断数据类型的办法

- typeof 判断基本数据类型
- instanceof 依据原型链判断
- constructor 对象的构造器
- Object.prototype.toString.call() 返回调用者的具体类型

## new操作符具体做了什么

```
1. 创建一个新的对象，在内存中创建一个新的地址
let obj = new Object()
2. 设置创建对象的原型链，继承构造函数的原型
obj._proto_ = 构造函数的.prototype
3. 将构造函数的this指向创建的对象
let result = Fn.call(创建的对象)
4. 判断构造函数的返回值类型
return result instanceof Object ? result:obj
```

## dom.onclick和dom.addEventListener区别？

dom.onclick:元素被点击是发生

- 可以在内联标签上添加事件，只能有一个，后来的会覆盖前者
- 潜在安全问题XSS跨站脚本攻击
- 内联不能分离文档结构和逻辑
- 只能处理冒泡阶段

dom.addEventListener:用于向元素添加事件，三个参数分别是事件、回调函数、是否在捕获和冒泡阶段执行

- 可以添加多个事件，按注册顺序执行
- 分离文档结构和逻辑
- 可以处理冒泡和捕获阶段，true表示在捕获阶段处理，false表示在冒泡阶段处理

## 作用域和作用域链

- 变量和函数可访问的范围，即作用域控制这个变量的可见性和生命周期
- 全局作用域，生命周期和页面生命周期等同
- 局部作用域，函数，{}内部声明的变量和函数

## 预解析和变量提升

预解析：JS引擎将JS所有var声明和function都提升到作用域的最前面

变量提升：将所有的变量声明提升到作用域的最前面

## 改变指向函数的三个方法

call和apply是使用后马上执行,bind是返回一个新的函数

call与apply的区别在于传参，call需要把参数列举出了

## ...args剩余参数和arguments对象的区别

- ...args只包含没有形参的实参，而arguments包含了传给函数的所有实参
- ...args是真正的Array实例，arguments不是真正的数组
- arguments还有附加属性callee

## 遍历方法

### 遍历数组

- for循环 
- forEach() 不能执行break和return
- map()
- for...of 可迭代的对象都可遍历

### 遍历对象

- for...in 遍历一个对象自由的、继承的、可枚举的、非Symbol的属性名
- Object.keys() 返回一个可枚举属性名组成的数组
- Object.values() 可枚举属性值
- Object.getOwnPropertyNames() 返回指定对象的所有自身属性名

### 遍历字符串

- for...of 
- for循环

## JS的NAN属性

NaN属性代表非数字值的特殊值，不可配置，不可写

NaN!==NaN

isNaN()判断是否为NaN

## null和undefined

```js
undefined == null //true
undefined === null //false
let a
typeof a //undefined
let b= null
typeof b //object
null表示空对象指针，JS的最初版本使用32位系统，为了性能考虑使用低位存储变量类型信息，000开头代表对象，而null表示为全零
```

## ===和==

==对比时，若类型不相同，会先转换为相同类型，然后再比较值

- 一个是null、一个是undefined、相等
- 一个是字符串、一个是数值、字符串转换为数值
- true/false转换为1/0
- 一个是对象、一个是数值和字符串
  - 先尝试valueOf()
  - toString()

===不会转换类型

## 0.1+0.2为什么不等于0.3

- 二进制存储
- 浮点数转换为整数计算

## 函数的length

- 形参的个数

```js
function fn1 () {}
function fn2 (name) {}
function fn3 (name, age) {}

console.log(fn1.length) // 0 
console.log(fn2.length) // 1 
console.log(fn3.length) // 2
```

- 第一个具有默认值之前的参数个数

```js
function fn1 (name) {} 
function fn2 (name = '林三心') {} 
function fn3 (name, age = 22) {} 
function fn4 (name, aaa, age = 22, gender) {} 
function fn5(name = '林三心', age, gender, aaa) {} 

console.log(fn1.length) // 1 
console.log(fn2.length) // 0 
console.log(fn3.length) // 1 
console.log(fn4.length) // 2
console.log(fn5.length) // 0
```

## DOM事件流

事件三要素：事件源、绑定事件、添加事件处理程序

事件流：

- 捕获阶段：DOM最顶层window开始，逐级向下寻找目标元素传播的过程，遇见绑定的捕获事件会向下传递
- 目标阶段：到达目标阶段出发绑定事件
- 冒泡阶段：事件开始由具体元素接受，逐级向上传播到DOM顶层window的过程

有了事件流，就可以控制事件在事件流的那一个环节执行

## 原型和原型链

## 中文的长度

js是unicode编码，所有的字符都是一个

前后端不一致的情况，可以用正则替换后再获取长度

## 简述cookie/session记录登录状态机制原理

第一次访问服务器，服务器会开辟一块空间来存放用户信息。

每一个登录之后的用户信息，都会以key-value格式记录在session中

同事服务器会把sessionId存在cookie中返回给客户端

客户端把sessionId保存在本地cookie中对应的网站记录下

下次访问携带这个sessionId

## 简述cookies、session、sessionStorage、localStorage区别

cookie

- 把数据存在用户的浏览器中
- 刷新页面不会丢失数据
- 只能存储字符串

session

- 位于web服务器，主要负责访问者与网站的交互，关闭网站时会话就已经结束

sessionStorage

- 生命周期为关闭浏览器
- 同一个窗口数据可共享
- 2.5m

localStorage

- 生命周期为永久
- 多个窗口共享
- 5m

cookie与sessionStorage、localStorage区别：

- cookie始终在同源的http请求中携带，另外两个不会自动发送到服务器
- cookie不能超过4k，另外两个可到5M以上
- 数据有效期不同：sessionStorage仅在浏览器窗口关闭之前有效，localStorage始终有效，窗口或浏览器关闭也一直保存；cookie在过期时间之前有效
- 作用域不同：sessionStorage在同一个的浏览器窗口共享，localStorage和cookie在所有同源窗口共享

## for-in与for-of区别

- for-in：用于遍历对象可枚举属性，包括对象的原型链中的属性，遍历数组的索引
- for-of：用于遍历可迭代对象，不会遍历原型，遍历数组的值

## 常见的事件

- 点击事件：onclick、ondblclick
- 焦点事件：onblur失去焦点、onfocus获得焦点
- 加载事件：onload
- 鼠标事件：onmosedown、onmouseup
- 键盘事件：onkeydown
- 选择和改变：onchange
- 表单事件：onsubmit

## JS严格模式

"use strict" 减少优于隐式转换、全局变量污染带来的安全问题

- 变量必须声明再使用
- 预编译时this为undefined，
- 不支持arguments、caller、callee、with
- 函数内部不能通过arguments修改参数值
- 不允许对变量或函数使用delete
- 不允许变量重名
- 不允许使用8进制
- 不可对对象的只读属性赋值
- 全局this不再指向window对象

## ~~字符

~是按位取反，~~会保持原值，并转化为int类型

正值相当于Math.floor(x)

## Map和Object区别

- 内存占用：同样的内存，map比object多存储50%的键值对
- 插入性能：有大量插入操作时map性能更好
- 查找速度：大数据量时差异较小，某些情况Object更好
- 删除性能：选择map

## 位运算符

位与&、位或|、位异或^、位非~

左移<<、右移>>、无符号右移>>>、无符号左移<<<

## delete删除性能

- 对象不存在也返回true，不能通过结果来判断
- 对象的属性存在并且不能删除时返回false
- 全局作用域或者var、function声明的无法用delete删除

## 浏览器缓存各个文件的具体缓存配置

Content-Length加Last-modified的哈希

## val、let、const

var：

- 声明提升
- 同一个作用域可以多次声明，最开始的会被覆盖
- 没有块级作用域
- 会绑定在顶层window对象上，其他两个不会

const：

- 不可重新赋值
- 引用类型例外
- 必须同时初始化和赋值
- 栈保存引用、堆保存值

let：

- 不会声明提升
- 可更改
- 不可重复声明

## 将值设置不可修改

Object.freeze:

- 不能添加删除属性
- 不能修改已有属性
- 对象原型也不能修改

Object.seal:

- 不能添加删除
- 可以修改已有属性

Object. preventExtensions：

- 不能添加新属性

## 箭头函数和普通函数

- 函数声明：function fc(){} 声明提升
- 函数表达式：let fc = function(){}
- 箭头函数：()=>{}

箭头函数：没有prototype属性、不能绑定arguments、没有this

## symbol类型

定义一个唯一的对象属性名，不可改变

- 作为属性名，解决全局变量名冲突的问题
- 不能用new构建   var s1 = Symbol("dish")
- 作为属性key，只能通过括号获取
- 不能被for-in迭代

## promise对象

三个状态：

- Pending ：初始状态，表示异步操作还在进行中
- Fulfilled：表示异步操作成功，此时会执行.then()方法的回调函数
- Rejected：异步操作失败，执行.catch()方法的回调函数

## arguments对象

- callee用于匿名函数递归
- 本身不是数组，但有length属性，可以索引元素
- 检测参数个数
- 模拟函数重载

## ArrayBuffer

操作二进制数据的一个接口

- ArrayBuffer代表原始二进制数据
  - TypedArray 读写简单的二进制数据
  - DataView读写复杂二进制数据

## 同步异步任务执行机制

- 同步任务在主线程上执行，形成一个执行栈
- 主线程之外，有一个"任务队列"，只要异步任务有了运行结果，就在任务队列放置一个事件
- 执行栈所有同步任务执行完毕，系统会读取任务队列

## 浏览器工作原理和V8引擎

### 浏览器内核

实质上是浏览器的排版引擎、页面渲染引擎、样板引擎

- webkit ：苹果基于KHTML开发的，用于safari
- Blink:webkit一个分支，用于Google、edge等

### 浏览器渲染过程

1. 解析HTML文件，构建DOM树
2. CSS解析，构建CSSOM树
3. 合并形成一个渲染树 Render tree
4. 布局计算，确定节点在屏幕中的位置和大小
5. 绘制在屏幕上
6. 重排和重绘

### v8引擎

- JS代码、词法语法分析、抽象语法树、解释为字节码、运行结果
- 上下文栈、预解析、变量提升、作用域、暂时性死区
- 基本类型存放在栈中分配
- 复杂类型存放在堆中，引用的指针在栈中
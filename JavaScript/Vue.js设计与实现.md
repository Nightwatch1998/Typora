## 框架设计概览

### 权衡的艺术

- 命令式和声明式：

  命令式关注过程，声明式关注结果。Vue的内部实现是命令式，暴露给用户是声明式。

- 性能和可维护性：

  性能上命令式更优，声明式多了查找变更的性能消耗。但是声明式可维护性高。

- 虚拟DOM的性能：**增量更新**

  虚拟DOM为了最小化**找出差异的性能消耗**。

  与innerHTML对比：

  - 创建页面差距不大
  - **更新页面**时差异较大，innerHTML需要销毁旧DOM元素，全量创建新的DOM元素。

- 运行时和编译时：

  - 纯运行时：灵活性高，性能和安全性低
  - **运行时+编译时**：保留灵活性，尽可能优化性能
  - 纯编译时：性能高，但灵活性较低

### 框架设计的额核心要素

- 提升用户的开发体验：控制台信息
- 控制框架代码的体积：__DEV__区分开发环境
- 做到良好的Tree-Shaking

```
/*#__PURE__*/  //告诉rollup.js没有副作用，可以放心删除
```

- 框架的构建产物：IIFE、ESM
- 特性开关：使用rollup.js的预定义常量插件实现
- 错误处理：统一错误处理接口

### vue3的设计思路

- **虚拟DOM**就是用JS对象来描述DOM，**渲染函数**返回的结果就是虚拟DOM
- **渲染器**的作用是将虚拟DOM渲染成真实DOM
- 组件的本质：组件就是一组虚拟DOM元素的封装，可以是**函数或者JS对象**
- **编译器**：作用是将template模板编译为渲染函数，并添加在script标签块的组件对象上

## 响应系统

### 响应式系统的作用与实现

1. 副作用函数effect，执行会直接或间接影响其他函数的执行。

2. 通过拦截字段的读取和设置操作，读取时，将effect放置在桶中，设置时，拿出effect并执行。需要将一个effrct函数绑定在一个某个对象的某个属性上。
3. 数据结构使用了**weakMap**、Map和Set。weakMap的键为对象，值为对一个map，存储该对象所有属性的依赖；Map中的key为对象的属性，值为key相关的响应函数集合set。把副作用函数收集到桶里的逻辑封装为track，把触发副作用函数执行的逻辑封装到trigger中。变量**activeEffect**至关重要
4. 分支切换带来的effect函数遗留问题：为effect添加依赖集合deps，每次执行时先把所有的相关依赖删除，这部分逻辑封装在**cleanup**里面，trigger中用一个新的set防止一直循环
5. 嵌套的effect和**effect栈**，避免相互影响
6. 避免无限递归循环，在同一个effect中读取和设置时会触发，**trigger前添加守卫**。
7. **调度执行**，让用户控制trigger的**执行方式、执行次数**、**执行时机**
8. 计算属性computed和lazy,添加值**缓存**、懒执行的副作用函数
9. watch的实现原理，**基于调度器实现**，**递归地watch对象的所有属性**，**获取旧值和新值**
10. 立即执行的watch和回调执行时机，**immediate**指定回调是否立即执行，**flush**指定同步和异步执行
11. 副作用过期，**OnInvalidate**注册过期回调，通过闭包exppired实现的

### 非原始值的响应式方案

#### 基本原理

1. Proxy能够拦截对象的基本操作，例如读取、复制、函数调用。
1. Reflect.get()，可以绕过对象的getter函数获取属性值

```
Reflect.get(target, propertyKey [, receiver])
```

target为对象，propertyKey为属性名，receiver表示 getter 函数的执行上下文对象

3. 常规对象和异质对象
4. 



#### 代理对象

#### 代理数组

#### 代理Set和Map

### 原始值的响应式方案

## 渲染器

## 组件化

## 编译器

## 服务端渲染
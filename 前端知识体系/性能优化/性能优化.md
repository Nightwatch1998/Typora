## 性能指标

三大核心指标：

- LCP：页面速度指标
- FID：交互体验指标
- CLS：页面稳定指标

### FP&FCP

FP (First Paint) 首次绘制，记录页面第一次绘制像素的时间

FCP(First Contentful Paint) **首次内容绘制**，记录页面首次绘制文本、图片、非空白Canvas或SVG的时间

FP<=FCP

### LCP

Largest Contentful Paint,最大内容绘制，用于记录视窗内**最大的元素**绘制的时间，会随着页面渲染变化而变化，会在用户第一次交互后停止记录

### TTI

Time to Interactive**首次可交互时间**

- 从FCP后开始计算
- 持续秒内无长任务，且无两个以上进行中的GET请求
- 往前回溯至5秒前的最后一个长任务结束的时间

### FID

First Input Delay，首次输入延迟，用户首次与页面交互到浏览器实际响应该事件的时间

用户交互事件触发到页面响应中间耗时多少，推荐100ms以内

### TBT

Total Blocking Time，阻塞总时间。记录FCP到TTI之间所有长任务的阻塞时间总和

长任务(执行时间大于50ms)

每个长任务的阻塞时间=**执行时间-50ms**

### CLS

Cumulative Layout Shift ，累计位移偏移，记录了页面上非预期的位移波动

页面渲染过程中突然插入巨大的图片等等

计算方式：**位移影响的面积*位移距离**，用屏幕面积百分比表示

推荐值低于0.1

## 获取指标工具

- lighthouse
- web-vitals-extension Chrome插件
- Chrome Devtools的Performance选项卡

## 页面的渲染过程

输入网址、解析URL、检查浏览器缓存、DNS解析、TCP/IP解析、HTTP请求、服务器请求并返回http报文、浏览器渲染页面、断开连接

### 输入网址

用户输入查询关键词时，地址栏会判断输入的是**关键字是搜索内容还是URL**

- 如果是搜索内容，会合成带搜索关键字的URL
- 如果符合URL，会添加协议合称为完整的URL

### 解析URL

协议、主机、端口、路径、查询参数、锚点

### DNS解析

获取目标网页IP地址的过程

1. 先递归查询DNS缓存
2. 查询根域名服务器
3. 查询com顶级域名服务器
4. 查询google.com域名服务器
5. 查询结果缓存

优化：

- DNS预解析：有多个不同的服务器资源时，可提前解析，避免卡顿
- DNS负载均衡：把访问引导到不同的服务器上

### TCP/IP连接

三次握手的过程

### 检查浏览器缓存(补充)

网络进程会查找本地缓存是否缓存了该资源，如果有，直接返回给浏览器进程。

浏览器缓存：

- 浏览器发送请求，会根据请求头expires和**cache-control**判断是否命中**强缓存策略**
- 未命中，会发送请求，根据**If-Modified-Since**和If-None-Match判断是否命中**协商缓存**
- 离线缓存，service worker

第三方库公共模块抽取：

- 设置较长的强缓存时间

### HTTP请求(重点看)

建立连接之后，浏览器会构建请求行、请求头等信息，并把cookie数据附加到请求头，然后发送请求。

开启HTTP2：

- HTTP1用文本，HTTP2用二进制分帧通信
- HTTP2可以多路复用，HTTP1会有并发限制
- HTTP2可以头部压缩，节省消息头占用的网络流量
- HTTP2可以服务端推送

### 服务器请求并返回http报文

## 浏览器渲染页面

### DOM树

字节->字符->令牌->节点->对象模型

构建流程：

- 转换：根据HTML原始字节，根据指定编码转换为字符 √
- 令牌化：将字符串转换为H5标准的各种令牌，从而识别每个元素 √
- 词法分析：发出的令牌转换为定义属性和规则的对象 √
- DOM构建：构建树结构 √

### CSS对象模型

构建过程：

- 解析CSS样式表：浏览器加载CSS样式后，会解析成一组样式规则
- 创建StyleSheet对象,表示**整个样式表** √
- 创建CSSRule对象，表示样式规则，包括**选择器和声明块** √
- 创建CSSStyleDeclaration**声明块对象**，表示声明块、样式属性和值
- 构建CSSOM树

CSSOM的每个节点代表一个CSS规则，包括选择器和声明块

### 布局树Layout Tree

- DOM树和CSSOM树合并形成渲染树 √
- 渲染树只包含网页所需的节点
- 布局计算每个对象精确位置和大小 √
- 使用最终渲染树将像素渲染在屏幕上 √

### 渲染

渲染流程：

- 获取DOM后分割为多个图层，通过**浏览器Layer**图层查看 √ 以下情况浏览器会将其分配到单个图层：
  - 应用CSS 3D变换和透视属性
  - 视频、canvas和webgl元素，**动态更新**
  - 具有滚动、动画和滑动效果的元素，**频繁重绘**
- 对每个图层的节点计算样式结果 √
- 为每个节点生成图形和位置 √
- 将每个节点绘制填充到图层位图中
- 图层作为纹理上传至GPU
- 组合多个图层到页面上生成最终图像

### 回流和重绘

- 重绘

页面中元素样式改变不影响在文档流中的位置时，例如color,bgc,visibility等等，浏览器会将新的样式赋予该元素并重新绘制。

- 回流

当渲染树中部分或者全部元素的尺寸、结构、或者某些属性发生改变时，浏览器重新渲染部分或全部文档的过程成为回流。

**引起回流的方式：**(页面排版发生了变化)

1. 页面首次渲染 √
2. 浏览器窗口大小发生变化 √
3. 元素尺寸或者位置发生变化 √
4. 元素内容和字体变化 √
5. 添加、删除DOM √
6. 激活CSS伪类
7. 查询某些属性或调用某些方法

**引起回流的属性和方法：**

- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- scrollIntoView()、scrollIntoViewIffNeeded()
- getComputedStyle()
- getBoundingClientRect()
- scrollTo()

## 性能优化(雅虎军规)

